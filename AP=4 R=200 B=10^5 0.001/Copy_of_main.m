AR=0.05;
load('AT50');
Arrtime=AT{round(AR*1000)};
% AR=0.05;
% Arrtime=1:1:100;
VMnum=10;
% a=21; Nap=10;
% AP_location=round(unifrnd(1,a,Nap,2));
% a=1000; Nap=2000;
% User_location=round(unifrnd(0,a,Nap,2));
user_location=[815,745;906,892;127,243;913,130;632,225;98,350;278,287;547,927;958,51;965,593;158,163;971,838;957,168;485,502;800,999;142,355;422,47;916,214;792,398;959,334;656,230;36,936;849,683;934,962;679,438;758,940;743,6;392,610;655,801;171,233;706,932;32,763;277,826;46,573;97,793;823,329;695,223;317,312;950,585;34,830;439,290;382,403;766,862;795,615;187,991;490,204;446,827;646,676;709,249;755,476;276,399;680,599;655,801;163,105;119,821;498,841;960,355;340,430;585,572;224,701;751,742;255,758;506,389;699,429;891,956;959,573;547,850;139,276;149,622;258,588;841,963;254,86;814,500;244,522;929,90;350,905;197,884;251,439;616,782;473,148;352,620;831,261;585,446;550,844;917,196;286,304;757,483;754,338;380,798;568,987;76,159;54,237;531,702;779,375;934,974;130,972;569,644;469,860;12,402;337,632;162,985;794,559;311,934;529,720;166,484;602,639;263,888;654,199;689,395;748,992;451,402;84,659;229,901;913,995;152,653;826,108;538,36;996,618;78,567;443,962;107,746;962,663;5,523;775,260;817,962;869,540;84,30;400,696;260,520;800,59;431,890;911,330;182,230;264,114;146,311;136,228;869,652;580,66;550,275;145,282;853,880;622,444;351,756;513,603;402,783;76,114;240,979;123,849;184,51;240,466;417,326;50,630;903,230;945,580;491,603;489,600;338,448;900,35;369,514;111,408;780,108;390,460;242,451;404,551;96,805;132,701;942,872;956,52;575,220;60,460;235,959;353,790;821,452;15,333;43,59;169,741;649,507;732,200;648,427;451,169;547,752;296,368;745,942;189,17;687,829;184,627;368,539;626,651;780,727;81,94;929,878;776,14;487,294;436,180;447,926;306,68;509,581;511,637;818,651;795,865;644,56;379,817;812,529;533,694;351,212;939,543;876,703;550,956;622,445;587,85;208,57;301,629;471,796;230,691;844,345;195,947;226,520;171,954;228,74;436,207;311,775;923,914;430,783;185,296;905,152;980,848;439,785;111,271;258,228;409,321;595,830;262,822;603,571;711,572;222,286;117,699;297,796;319,442;424,446;508,466;86,279;262,675;801,904;29,909;929,747;730,261;489,690;579,132;237,124;459,191;963,146;547,585;521,73;232,822;489,723;624,926;679,493;396,655;367,890;988,539;38,282;885,976;913,36;796,326;99,973;262,365;335,309;680,121;137,916;721,135;107,332;654,897;494,500;779,615;715,583;904,698;891,29;334,528;699,32;198,827;31,340;744,847;500,246;480,581;905,938;610,48;618,54;859,21;805,681;577,599;183,114;240,796;887,618;29,70;490,69;168,136;979,789;713,92;500,238;471,244;60,105;682,858;42,698;71,734;522,651;97,516;818,326;818,662;722,118;150,148;660,20;519,964;973,970;649,124;800,467;454,657;432,290;825,755;83,558;133,428;173,267;391,754;831,898;803,728;60,407;399,938;527,255;417,533;657,955;628,268;292,250;432,928;15,69;984,299;167,592;106,203;372,636;198,798;490,502;339,651;952,796;920,233;53,601;738,112;269,516;423,838;548,921;943,498;418,278;983,653;301,917;701,510;666,974;539,197;698,111;667,297;178,396;128,421;999,311;171,694;33,92;561,402;882,295;669,306;190,106;369,594;461,283;982,155;156,1;856,284;645,551;376,871;191,42;428,905;482,131;121,834;590,800;226,918;385,137;583,505;252,405;290,174;617,575;265,606;824,214;983,520;730,989;344,490;584,695;108,411;906,35;880,293;818,801;261,347;594,83;23,511;425,367;313,739;161,525;179,805;423,817;94,189;599,124;471,821;696,638;700,16;639,896;34,515;69,545;320,606;531,760;654,855;408,383;820,85;718,734;969,332;531,840;325,372;106,828;611,177;779,130;423,880;91,44;266,687;154,734;281,437;440,380;527,980;457,399;875,440;518,157;944,326;638,314;958,895;241,247;676,311;289,409;672,708;695,144;68,871;255,83;224,462;668,30;844,753;344,700;781,215;675,680;7,557;602,851;387,559;916,902;1,420;462,358;424,489;461,256;770,929;322,467;785,254;471,431;36,703;176,402;722,182;473,856;153,584;341,374;607,222;192,219;738,522;243,433;917,741;269,70;766,847;189,680;287,137;91,858;576,200;683,607;547,543;426,162;644,6;648,771;679,765;636,421;945,57;209,586;709,174;236,729;119,534;607,253;450,917;459,758;662,887;770,69;350,184;662,737;416,697;842,777;833,502;256,425;613,611;582,856;541,671;870,524;265,299;318,704;119,382;940,568;646,888;479,843;639,899;545,939;647,815;544,1;721,3;522,87;994,261;219,23;106,424;110,341;64,541;405,926;448,298;366,338;764,859;628,340;772,138;933,508;973,857;192,384;139,696;696,628;94,450;525,474;530,950;861,83;485,280;393,447;671,588;741,878;520,469;348,437;150,746;586,468;262,861;44,467;755,498;243,487;442,229;688,86;359,67;736,888;395,233;683,862;704,712;442,873;20,938;331,140;424,394;270,981;197,645;822,896;430,482;888,14;391,623;769,231;397,527;809,725;755,607;377,588;216,433;790,244;949,429;328,10;671,609;439,958;834,95;769,36;167,886;862,247;990,9;514,815;884,140;588,880;155,95;200,353;407,593;749,585;826,668;790,648;319,433;534,140;90,752;112,242;136,650;679,857;495,84;190,972;495,31;148,835;55,836;851,50;561,546;930,943;697,321;583,806;815,601;879,790;989,799;1,50;865,283;613,653;990,490;528,973;480,748;801,568;228,299;498,256;901,887;575,447;845,816;739,98;586,860;247,28;666,899;83,900;626,524;661,120;730,178;891,706;982,831;769,35;581,758;928,957;580,343;17,638;121,343;863,216;484,786;845,723;209,279;552,582;630,421;32,92;615,24;362,491;50,278;490,340;193,287;123,171;205,399;147,698;189,204;43,666;635,443;282,433;539,175;695,193;499,616;536,269;445,560;124,945;490,714;853,679;874,959;270,775;208,608;565,948;640,60;417,269;206,987;948,772;82,475;106,681;142,417;166,380;621,213;574,383;52,30;931,472;729,333;738,976;63,555;860,846;934,408;984,462;859,826;786,991;513,524;178,925;399,739;134,567;31,969;939,824;301,960;296,646;333,380;467,477;648,912;25,15;842,157;559,472;854,543;348,60;446,658;54,890;177,110;663,438;331,280;898,985;118,609;988,254;540,133;707,545;999,828;288,837;415,833;465,204;764,544;818,875;100,121;178,856;360,900;57,218;522,77;336,474;176,835;209,469;905,414;675,503;468,125;912,132;104,870;746,603;736,265;562,865;184,58;597,458;300,722;134,339;213,401;895,527;71,894;242,778;54,69;442,279;13,379;897,865;197,420;93,240;307,598;456,479;102,899;995,935;332,818;297,709;62,743;298,900;46,65;505,336;761,4;631,828;90,507;81,366;777,227;905,535;534,289;109,68;826,85;338,68;294,410;746,123;10,443;48,899;668,354;603,120;526,569;730,875;707,349;781,42;288,142;693,77;557,741;397,457;62,668;780,699;338,571;608,629;741,878;105,662;128,875;550,468;485,141;890,68;799,714;734,308;51,671;73,652;89,531;798,715;943,505;684,488;132,498;723,936;110,389;117,117;641,240;329,685;654,839;749,970;583,215;740,760;235,584;735,403;971,510;867,496;86,651;366,744;369,302;685,90;598,826;789,390;368,775;206,179;87,109;772,905;206,876;388,1000;552,864;229,37;642,545;484,998;152,511;782,874;101,70;294,988;237,923;531,564;91,431;405,338;105,721;112,14;784,374;292,923;604,546;964,474;432,497;695,309;758,951;433,982;655,514;110,993;934,456;187,426;266,213;798,193;488,833;769,727;396,530;273,829;37,512;673,552;430,213;452,588;610,143;59,52;316,683;773,609;696,220;125,406;130,630;92,555;8,128;423,169;656,1;723,418;531,488;109,160;632,667;126,18;134,120;99,952;142,976;168,31;196,494;317,863;316,243;218,834;251,814;893,629;703,2;556,380;184,904;212,680;77,379;914,632;707,243;558,571;313,982;166,850;622,283;988,682;170,358;258,987;397,84;74,250;684,811;402,84;983,531;402,801;621,739;154,142;381,438;161,350;758,478;871,587;351,146;686,905;294,640;531,163;832,566;597,932;335,783;299,686;453,466;423,260;360,569;558,249;743,319;424,911;429,885;125,795;24,926;290,179;318,518;654,627;957,913;936,664;458,389;240,740;764,818;759,600;741,85;744,922;106,54;682,527;463,119;212,380;99,813;824,244;175,884;164,713;666,378;894,249;517,253;703,767;154,50;953,685;541,620;680,747;37,977;809,384;749,260;120,877;525,806;326,461;546,91;399,564;415,187;181,532;255,355;21,315;924,727;654,516;933,791;164,204;921,678;795,52;577,801;440,679;258,946;752,92;229,908;64,510;767,615;671,316;715,77;642,851;419,145;391,370;816,622;317,998;815,517;789,991;852,227;506,398;636,697;951,65;444,748;60,420;867,811;631,380;355,319;997,986;224,718;652,413;605,99;387,735;142,637;25,74;421,121;184,982;726,497;370,22;842,54;734,141;571,893;177,466;957,561;265,494;925,68;224,898;374,289;88,269;640,594;181,476;45,368;723,656;347,938;661,620;384,283;627,205;22,439;911,27;801,876;746,610;813,204;383,520;617,54;575,862;530,443;275,548;249,567;452,680;228,371;804,78;986,456;30,48;536,738;87,38;802,954;989,742;67,937;939,513;18,241;684,260;784,759;534,993;885,357;899,753;626,110;138,597;218,431;182,731;42,261;107,95;616,451;940,640;354,132;411,453;984,652;946,827;677,308;988,402;767,884;337,701;662,242;244,760;296,291;680,277;528,6;412,375;603,437;751,304;584,291;552,243;584,937;512,860;83,397;720,479;996,565;355,490;971,270;346,990;887,184;455,862;413,33;218,332;126,749;309,644;726,169;783,952;694,543;10,251;843,579;922,915;771,896;43,483;378,443;704,312;730,55;224,754;269,132;673,356;477,396;624,886;236,21;177,844;830,288;767,250;934,488;108,729;182,203;99,216;490,976;193,593;896,304;99,968;44,896;557,190;772,2;312,712;179,868;339,118;210,39;510,598;906,604;629,516;102,8;391,689;55,946;501,874;432,113;998,355;812,242;486,560;894,613;138,301;390,798;927,796;917,781;714,351;618,54;343,709;936,993;125,162;731,114;646,913;833,482;398,852;750,810;835,187;322,247;552,54;979,609;549,777;330,511;619,28;361,990;757,501;414,332;492,174;695,626;973,575;328,751;838,154;739,357;954,144;32,851;357,338;663,275;282,6;230,802;711,497;625,538;591,871;660,723;48,668;349,179;451,550;241,960;715,596;856,809;282,985;731,886;138,214;837,35;139,451;588,14;366,474;807,951;504,249;490,386;877,431;353,831;449,825;964,453;42,381;973,926;189,741;667,738;586,947;675,510;361,792;620,452;811,849;19,390;84,738;975,976;651,523;231,430;403,207;122,323;268,111;258,375;332,330;152,342;348,817;122,532;884,521;94,774;930,120;399,625;47,347;342,335;736,575;795,864;545,199;686,672;894,902;55,199;304,298;46,497;195,890;720,501;722,277;878,534;582,574;71,413;923,15;800,703;286,507;544,381;985,65;716,359;839,234;433,204;471,814;561,393;269,54;749,375;504,775;647,165;308,912;139,319;476,330;362,204;788,767;780,70;669,950;134,158;22,286;560,687;301,141;939,512;981,721;287,929;801,732;896,750;598,407;884,239;944,521;549,219;728,842;577,663;26,816;447,794;646,469;521,310;372,688;937,987;830,770;849,830;373,706;593,595;873,753;934,497;668,865;207,68;654,969;72,99;407,547;667,403;934,107;811,724;485,614;757,783;417,567;972,811;988,577;864,944;389,871;455,508;247,789;784,473;883,829;914,322;558,976;599,278;149,73;900,751;450,831;206,922;900,327;763,804;882,538;285,463;673,821;664,952;123,76;407,709;275,235;717,399;283,268;896,833;827,995;390,650;498,704;695,932;834,688;610,568;575,381;326,635;456,363;714,408;884,369;721,468;19,503;675,911;439,206;438,339;117,574;815,487;325,262;246,580;343,878;376,61;547,441;562,84;396,563;398,539;515,768;658,233;951,587;722,459;400,861;832,661;134,354;60,347;84,254;164,953;324,298;302,158;12,361;540,742;95,706;147,701;631,6;859,374;974,901;571,318;997,597;554,298;515,125;331,388;430,818;492,981;71,862;888,84;65,338;436,236;827,318;395,984;613,548;819,749;886,842;931,167;191,903;259,105;898,745;593,729;504,717;613,133;819,446;532,509;202,530;454,860;428,678;966,806;620,531;695,956;720,67;347,542;517,282;557,481;156,685;562,208;695,608;426,326;836,881;731,133;360,102;454,959;386,153;776,153;734,156;430,90;694,454;945,669;784,831;706,790;109,713;390,473;591,709;459,958;50,506;229,305;834,790;16,236;864,234;78,465;669,619;500,615;218,123;572,124;122,284;671,736;600,411;56,829;56,935;153,399;20,52;435,571;832,748;617,320;520,493;864,222;98,939;908,482;108,540;517,221;143,96;559,60;5,820;767,771;849,196;917,895;987,684;505,657;271,990;101,34;508,424;586,490;763,584;83,83;662,660;517,52;171,557;939,712;590,488;441,618;942,214;656,646;452,381;840,104;533,378;554,263;680,241;367,623;239,523;579,413;867,218;407,859;113,861;444,284;300,615;401,779;833,955;404,920;390,385;360,163;140,797;260,114;87,159;429,356;257,848;298,583;425,586;119,926;495,575;706,10;244,809;785,609;74,480;394,268;3,258;221,481;1,227;189,49;142,169;268,258;175,198;139,606;599,824;901,811;939,802;221,708;483,859;376,781;524,204;265,993;68,94;436,651;174,215;26,244;955,340;431,198;962,507;762,951;7,395;680,584;706,607;645,715;552,402;218,859;772,920;228,751;371,286;891,797;856,143;402,505;318,611;609,704;910,383;909,729;592,887;333,56;853,138;442,863;904,422;33,411;532,959;716,750;179,981;337,234;188,96;322,385;404,500;549,570;49,977;553,493;275,401;242,995;243,261;154,665;956,964;936,671;819,299;728,531;176,1;360,884;189,404;1,301;316,951;700,461;625,288;543,85;439,582;287,153;502,73;762,581;762,287;576,362;748,725;646,858;123,348;504,962;347,954;92,206;148,768;198,616;672,919;432,603;694,702;257,744;10,385;532,252;279,37;946,472;906,645;393,279;25,518;671,246;837,298;971,650;57,891;450,861;582,210;687,399;719,888;650,257;727,967;374,619;582,165;116,826;58,656;980,546;285,251;595,40;962,233;186,361;193,633;342,986;933,207;391,757;273,886;152,472;397,159;375,811;131,477;435,116;92,876;615,635;11,97;573,908;790,35;235,40;448,989;569,686;61,377;496,504;642,763;221,49;837,726;971,701;846,459;506,582;279,339;747,171;237,399;957,920;620,226;600,361;173,325;90,84;255,513;859,833;911,905;700,724;725,383;230,298;576,692;811,880;404,925;988,81;90,483;321,128;511,253;61,884;726,196;557,121;529,544;830,315;859,382;789,792;318,839;452,680;752,417;110,643;110,214;270,617;525,675;973,601;710,346;312,364;291,171;850,795;912,493;639,355;255,775;89,237;838,845;585,817;948,846;61,370;585,383;285,861;828,464;191,571;443,695;393,961;827,546;677,637;208,571;318,927;134,864;671,170;571,179;170,244;148,752;476,199;908,983;552,710;33,175;54,858;805,909;451,962;383,571;790,563;364,177;532,514;712,548;871,165;329,494;650,535;975,199;76,623;587,26;414,319;309,533;264,327;759,602;995,362;187,135;781,914;196,641;992,659;802,675;424,745;729,842;498,517;809,152;357,381;73,821;591,171;910,330;194,966;432,806;749,222;39,1000;946,64;764,425;559,404;184,400;498,112;518,424;994,614;855,988;962,220;679,354;404,266;935,291;479,188;232,23;396,449;705,244;559,869;757,529;995,914;962,974;535,585;964,119;116,927;51,594;304,884;580,424;531,607;901,71;541,925;432,642;543,104;712,700;17,396;801,85;143,214;478,249;257,227;369,703;662,754;170,547;279,553;198,631;195,985;327,634;880,600;471,909;404,571;179,335;969,957;407,440;844,602;615,720;377,679;877,213;785,82;465,274;814,868;898,559;429,465;334,430;597,774;902,654;702,658;377,161;735,432;954,505;543,375;540,480;311,342;71,777;182,384;93,712;463,481;9,729;915,938;643,517;1,903;30,218;208,873;455,83;127,465;9,22;727,808;354,179;780,165;437,182;437,691;49,214;50,298;91,768;594,501;241,909;841,58;857,437;964,572;489,565;220,824;226,126;537,300;762,2;348,951;461,766;639,751;917,139;162,349;716,151;578,497;433,809;884,633;393,688;179,640;633,729;624,860;328,627;803,181;999,573;981,164;127,906;232,77;24,339;607,581;111,475;407,805;884,531;548,227;369,709;208,149;441,658;956,634;124,229;471,182;857,166;43,150;692,203;979,955;283,16;134,958;685,26;909,971;611,298;900,525;193,862;754,896;346,189;419,661;156,941;819,976;625,108;739,179;805,747;67,49;951,71;498,489;755,850;742,997;831,4;157,543;457,861;618,909;932,845;835,879;895,746;583,117;583,509;855,169;35,831;885,928;408,169;36,884;746,388;155,383;144,271;606,868;254,742;324,448;402,710;406,944;386,174;610,245;167,641;188,809;95,853;323,398;770,115;234,80;740,360;693,829;824,215;828,791;293,655;309,26;523,786;325,923;832,492;810,834;557,131;263,760;681,926;234,833;456,259;385,213;539,522;992,397;755,479;980,994;235,604;529,945;51,490;757,438;602,773;857,744;988,443;929,53;410,88;0,798;541,656;208,32;219,557;326,720;96,110;748,217;749,811;543,139;338,882;832,924;553,13;958,377;893,168;357,540;546,102;347,39;623,933;797,972;746,361;126,644;822,68;25,208;414,40;731,469;781,150;367,991];
% AP_location=[15,17;2,15;7,7;2,20;3,2];
AP_location=[1,16;16,3;18,14;19,11;21,4;11,20;6,13;3,10;11,20;13,14];
% AP_location=[11,17;15,6;19,20;20,8;12,5;4,6;4,13;6,10;18,8;6,18];
% AP_location=[8,9;19,15;10,16;9,5;5,6;4,14;7,11;16,13;17,6;15,5;1,18;18,16;19,20;16,3;2,5];
% AP_location=[13,7;12,12;19,4;7,13;16,6;16,14;9,15;12,16;3,10;2,3;12,6;17,19;20,4;4,18;12,12;10,21;1,3;8,10;4,3;17,20];
% plot(AP_location(:,1),AP_location(:,2),'.');
% Model=cell(1,size(AP_location,1));%服务模式，每一个cell中放了这种模式使用的AP的标号
% AP_distance=zeros(size(AP_location,1),size(AP_location,1));
% for i=1:size(AP_location,1)
%     for j=1:size(AP_location,1)
%         AP_distace(i,j)=sqrt(((AP_location(i,1)-1)*50-(AP_location(j,1)-1)*50)^2+((AP_location(i,2)-1)*50-(AP_location(j,2)-1)*50)^2);
%         if sqrt(((AP_location(i,1)-1)*50-(AP_location(j,1)-1)*50)^2+((AP_location(i,2)-1)*50-(AP_location(j,2)-1)*50)^2)<=500
%             Model{i}(end+1)=j;
%         end
%     end
% end
% AP_mul=[];%AP被不同的服务模式使用的次数
% for i=1:length(Model)
%     temp=0;
%     for j=1:length(Model)
%         if isempty(find(Model{j}==i))~=1
%             temp=temp+1;
%         end
%     end
%     AP_mul(end+1)=temp;
% end




AP_num=1:size(AP_location,1);
Model_temp=cell(1,size(AP_location,1));
for i=1:size(AP_location,1)
    Model_temp{i}=combnk(AP_num,i);
end
Model=zeros(1,size(AP_location,1));%放入总共的模式，是一个矩阵，矩阵长度不足的用0填充
for i=1:length(Model_temp)
    temp=Model_temp{i};
    for j=1:size(temp,1)
        temp1=temp(j,:);
        temp2=[];
        for k=1:length(temp1)
            for l=1:length(temp1)
                temp2(end+1)=sqrt(((AP_location(temp1(k),1)-1)*50-(AP_location(temp1(l),1)-1)*50)^2+((AP_location(temp1(k),2)-1)*50-(AP_location(temp1(l),2)-1)*50)^2);
            end
        end
        if isempty(find(temp2>500))==1
            %            temp4=size(Model,1);
            Model(end+1,:)=zeros;
            Model(end,1:length(temp1))=temp1;
        end
    end
end
Model(1,:)=[];
for i=1:size(AP_location,1)
    Model(1,:)=[];
end
sever_choose_from=cell(1,size(user_location,1));
for i=1:size(user_location,1)
    distance=[];
    for j=1:size(AP_location,1)
        distance(end+1)=sqrt(((AP_location(j,1)-1)*50-user_location(i,1))^2+((AP_location(j,2)-1)*50-user_location(i,2))^2);
    end
    [~,close_ap]=min(distance);
    for j=1:size(Model,1)
        if isempty(find(Model(j,:)==close_ap))~=1
            sever_choose_from{i}(end+1)=j;
        end
    end
end


Pap=100000;%单个AP的执行能力
VMnum=10;
% Channum=20;
Transferdata=[0,0,0,0,0,8334624,8362898,0,8287354,0,0,0,0,0,0,0,8326168,0,0,0,0,0,0,0,0;0,0,0,0,0,8343702,8371246,8311060,0,8301204,0,8340796,8311328,0,0,0,0,8323662,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,8314244,8299612,8304794,0,0,0,0,0,0,0,8364646,0,0,0,0,0,0;0,0,0,0,0,0,0,8348008,0,0,0,8346144,0,8326392,0,0,0,0,0,8341716,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,8307042,8282778,0,0,0,0,0,0,8315294,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,408676,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,314473,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,228889,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,176628,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,233738,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,251473,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,271522,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,313399,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,297528,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1889,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,265,265,265,265,265,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8326168,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8323662,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8364646,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8341716,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8315294,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1599,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,93019228,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1861129;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
%     data_name=['AR=',num2str(AR*1000),' system=2'];
%计算任务的关系D
D=zeros(size(Transferdata,1),size(Transferdata,2));
for i=1:size(Transferdata,1)
    for j=1:size(Transferdata,2)
        if Transferdata(i,j)>0
            D(i,j)=1;
        end
    end
end
E=zeros(size(D,1)+2,size(D,2)+2);
E(2:end-1,2:end-1)=D;%加entry exit
Hel=sum(E);%列求和
Heh=sum(E,2);%行求和
for j=2:size(E)-1
    if Hel(j)==0;
        E(1,j)=1;
    end
end   %加entry后的任务关系
for i=2:size(E)-1
    if Heh(i)==0;
        E(i,size(E))=1;
    end
end   %加exit后的任务关系

K=cell(2,size(E,2));
for i=1:size(E,2)
    K{1,i}=(find(E(:,i)))';%前节点,
    K{2,i}=find(E(i,:));%后节点，前后驱节点都变成是横向的
end   %计算直接前驱后驱任务


B=10.^6;
Transferdataq=zeros(size(Transferdata,1)+2,size(Transferdata,2)+2);
Transferdataq(2:end-1,2:end-1)=Transferdata;
Trantime=Transferdata/B;
Trantimeq=Transferdataq/B;

I=[1339000,1383000,1336000,1360000,1378000,1059000,1059000,1088000,1081000,1049000,1051000,1051000,1062000,1037000.00000000,72000,142000,1039000,1064000,1083000,1093000,1076000,139000,303000,386000,45000];
Iq=[0 I 0];
Exetime=zeros(size(AP_location,1),size(D,2));
for i=1:size(D,2)
    for j=1:size(AP_location,1)
        Exetime(j,i)=I(i)/(Pap/VMnum);
    end
end
Exetimeq=zeros(size(AP_location,1),size(E,2));
Exetimeq(:,2:end-1)=Exetime;


V=zeros(1,size(D,2));
for i=1:size(D,2)
    heExetime=0;
    for j=1:size(AP_location,1)
        heExetime=heExetime+Exetime(j,i);
    end
    V(i)=heExetime/size(AP_location,1);
end   %计算每个任务MeanExetime，加入向量V中
Vq=[0 V 0];
[rank]=pri(K,Vq,Trantimeq);
ranksign=rank;
ranksign(1)=0; %已经被定义为全局的变量，在前面的程序中，看是否被sign
PCPcell={};
[PCPcell,ranksign] = SearchPCP(1,PCPcell,ranksign,K);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%三种算法，只激活一个%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%   PCP     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sever=cell(size(Model,1),3);
for i=1:size(Model,1)
    
    P=ones(1,length(find(Model(i,:))))*Pap/VMnum;
    [  Map,TSF,Assignrank ] = AssignPCP( PCPcell,K,Exetimeq,rank,P,Trantimeq );
    sever{i,1}=Map;
    sever{i,2}=TSF;
    sever{i,3}=Assignrank;
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%   HEFT    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [ Map,TSF,Assignrank] = HEFT( rank,P,K,Exetimeq,Trantimeq);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%   PSO     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [ gMap ] = PSO( rank,Trantimeq,K,Exetimeq,P );




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%第二阶段，AP在二维平面中位置的选取%%%%%%%%%%%%%%%%%%%%
% %某AP的内部与外部的数据传输次数LP,包括自己
% LP=zeros(size(AP_location,1),size(AP_location,1));
% for i=1:size(AP_location,1)
%     locagather=find(Map(:,i));
%     for k=1:length(locagather)
%         temp1=Assignrank(locagather(k));
%         for l=1:length(K{2,temp1})
%             temp2=find(Assignrank==K{2,temp1}(l));
%             temp3=find(Map(temp2,:));
%             LP(i,temp3)=LP(i,temp3)+1;
%         end
%     end
% end
% %去除自己
% LPqu=LP;
% for i=1:size(AP_location,1)
%     LPqu(i,i)=0;
% end
%网格的选取，节点上放AP
% x=0:50:1000;
% y=0:50:1000;
% Point=[];
% for i=1:length(x)
%     for j=1:length(y)
%         Point(end+1,:)=[x(i),y(j)];
%     end
% end
%[ locagather,maxarray ] = AssignAP( LP,Point,P ,LPqu);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%第三阶段，信道分配%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [ Channel ] = Chanassign( Channum,P,LPqu );
Channel=cell(size(AP_location,1),size(AP_location,1));
for i=1:size(AP_location,1)
    for j=1:size(AP_location,1)
        if i~=j
            if sqrt(((AP_location(i,1)-1)*50-(AP_location(j,1)-1)*50)^2+((AP_location(i,2)-1)*50-(AP_location(j,2)-1)*50)^2)<=500
                Channel{i,j}=[1];
            end
        end
    end
end
B=10^6;
data_name=['AP=',num2str(size(AP_location,1)),' B=',num2str(B),' AR=',num2str(AR*1000)];
% data_name=['AP=',num2str(size(AP_location,1)),' Channel=',num2str(length(Channel{1,1})),' VM=',num2str(VMnum),' AR=',num2str(AR*1000)];
%%%%%%%%VM2Task的结构数组%%%%%%%%%
for vm=1:size(AP_location,1)/2*VMnum %一共十个，每一个对应一个VM，内部装着属于各个AP的相应VM编号的Task
    for i=1:length(rank)
        VM2Task(vm).user_id=0;
        VM2Task(vm).Task(i).rei=Iq(i); %任务剩余量的声明并初始化
        VM2Task(vm).Task(i).Task_id=i;
        temp=find(i==Assignrank);
        VM2Task(vm).Task(i).Map_AP=0;%任务的服务器选择的初始化
        VM2Task(vm).Task(i).pre=K{1,i};
        VM2Task(vm).Task(i).suc=K{2,i};
        VM2Task(vm).reTransferdata=Transferdataq;
    end
end

%%%%%%%AP的结构数组%%%%%%%%%
task_id_list=cell(1,size(AP_location,1));% 这个id是真实的Task的任务顺序
for i=1:size(AP_location,1)
    AP(i).AP_id=i;
end

LPqu=zeros(size(AP_location,1),size(AP_location,1));
for i=1:size(AP_location,1)
    for j=1:size(AP_location,1)
        if isempty(find(Channel{i,j}))~=1;
            LPqu(i,j)=1;
        end
    end
end

%%%%%%%CS的结构数组%%%%%%%%%
for ap=1:size(AP_location,1)
    temp=find(LPqu(ap,:));
    for cs=1:length(temp)
        AP(ap).CS(cs).from=ap;
        AP(ap).CS(cs).to=temp(cs);
        AP(ap).CS(cs).channel_num=Channel{ap,temp(cs)};
        AP(ap).CS(cs).pointer=1;%指针，指向，不断地增加，指向不同的queue
        for que=1:VMnum
            AP(ap).CS(cs).queue(que).state=0;
            AP(ap).CS(cs).queue(que).from_vm=vm;
            AP(ap).CS(cs).queue(que).front=1;
            AP(ap).CS(cs).queue(que).rear=1;
            AP(ap).CS(cs).queue(que).data.from_task=0;
            AP(ap).CS(cs).queue(que).data.to_task=0;
            AP(ap).CS(cs).queue(que).data.amount=0;
            AP(ap).CS(cs).queue(que).data.from_vm_id=0;
            AP(ap).CS(cs).queue(que).data.gt=0;
            AP(ap).CS(cs).queue(que).data.tft=0;
            AP(ap).CS(cs).queue(que).data.tat=0;
            AP(ap).CS(cs).queue(que).data.last_trans_clock=0;
        end
    end
end

%%%%%%%VM的结构数组%%%%%%%%%
% task_list=cell(1,size(AP_location,1));% 里边装的是task 也是结构体
% for ap=1:size(AP_location,1)
%     temp=(find(Map(:,ap)))';
%     temp1=cell(1,length(temp));
%     for j=1:length(temp)
%         temp1{1,j}=VM2Task(ap).Task(Assignrank(temp(j)));
%     end
%     task_list{1,ap}=temp1;
% end
for ap=1:size(AP_location,1)
    %     temp=(find(Map(:,ap)))';
    %     temp1=cell(1,length(temp));
    for vm=1:VMnum
        %         for j=1:length(temp)
        %             temp1{1,j}=VM2Task(vm).Task(Assignrank(temp(j)));
        %         end
        AP(ap).VM(vm).Pvm=Pap/VMnum;
        AP(ap).VM(vm).id=vm;
        AP(ap).VM(vm).state=0;%运行状态
        AP(ap).VM(vm).Nowin=0; %现在正在执行的任务,初始化指向1
        %         AP(ap).VM(vm).task_list=temp1;
        AP(ap).VM(vm).cat=0;%接入点r的虚拟机v的计算时间累计
    end
end
% for i=1:size(AP_location,1)
%
% end

clock=0;
clock_step=1;
user_max=50;
Can=1;
Tmax=100000;
% timechoice=unifrnd(1,Tmax,1,user_max);
% load('AT50');
% AR_array=[23 24 26 27]*10^(-3);
% for ar=1:length(AR_array)
%     AR=AR_array(ar);
%     Arrtime=AT{round(AR*1000)};
% end

% Arrtime=[1];
% Arrtimesign=Arrtime;

user_state=[];%第一行被系统接纳时间，第二行用户结束时间
Arrtimesign=Arrtime;
sign=ones(1,length(rank)-1);

% for i=1:63
%     Table(i).time=[];
% end
AP_used_vm=zeros(1,size(AP_location,1));%放入每个AP被占用的VM的数目
user_sever_choose=cell(2,size(user_location,1));%cell中的矩阵，第一行是AP的选择，对应的第二行是算选择的VM的编号
while clock<Tmax
    %%%%%%%%%%%%%%%%%按照user数分配各个user的VM%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %     if isempty(find(clock<Arrtime<clock+clock_step))==0
    Can=1;%可以运行，就是有空闲的VM
    while isempty(find(Arrtimesign))~=1&&Arrtimesign(min(find(Arrtimesign)))<clock+clock_step&&Can==1%到达时间小于clock且VM中有空闲，可以运行的标志为1
        user=min(find(Arrtimesign));
        temp=sever_choose_from{user};%可供选择的Model放入temp中
        temp3=zeros(1,length(temp));%temp3放入每个Model中AP的最大使用的VM数
        for i=1:length(temp)
            temp1=Model(temp(i),:);
            temp2=temp1(temp1~=0);%第i种Model用AP标号
            [temp3(i),~]=max(AP_used_vm(temp2));%这些AP的VM用的数目的最大值
        end
        [~,temp4]=min(temp3);%temp3中最小的就是要选择的Model
        user_sever_choose{1,user}=temp(temp4);
        temp=Model( user_sever_choose{1,user},:);
        AP_real=temp(temp~=0);%真实的AP
        user_sever_choose{2,user}=AP_real;
        Assignrank=sever{user_sever_choose{1,user},3};
        Map=sever{user_sever_choose{1,user},1};
        temp_VMchoose=[];%以下是对VM2Task的选择
        if min(temp3)<VMnum
            for vm=1:length(VM2Task)
                if  VM2Task(vm).user_id==0
                    VM2Task(vm).user_id=user;   %把VM2Task中的数据变为这个user专属的
                    for i=1:length(rank)
                        VM2Task(vm).Task(i).Map_AP=user_sever_choose{2,user}(1,find(Map(find(Assignrank==i),:)));
                    end
                    break
                end
            end
            for ap=1:length(AP_real)
                for vm=1:VMnum
                    if  AP(AP_real(ap)).VM(vm).state==0
                        AP(AP_real(ap)).VM(vm).state=2;%VM的状态设置为1
                        AP(AP_real(ap)).VM(vm).user_id=user;%同一个user使用不同AP的相同编号的VM
                        AP(AP_real(ap)).VM(vm).Nowin=1;
                        AP(AP_real(ap)).VM(vm).cat=0;
                        temp=find(Map(:,ap));
                        AP(AP_real(ap)).VM(vm).task_list=Assignrank(temp');
                        user_state(1,user)=clock; %记下用户开始时间，这一时刻的结尾，下一个时刻的开始为计时点
                        Arrtimesign(user)=0;
                        temp_VMchoose(end+1)=vm;
                        break %跳出 vm=1:VMnum这一循环
                    end
                end
            end
            for ap=1:size(AP_location,1)
                temp=0;
                for vm=1:VMnum
                    if AP(ap).VM(vm).state~=0
                        temp=1+temp;
                    end
                end
                AP_used_vm(ap)=temp;
            end
            if min(temp3)==VMnum-1
                Can=0;
            end
        else
            Can=0;
        end
        if isempty(temp_VMchoose)~=1
            user_sever_choose{2,user}(2,:)=temp_VMchoose;
        end
        if Can==0
        end
    end  %各个任务的VM已经给分配好了

    %     end
    %clock0时刻到clock1时刻,从上面的过程当中，AP，
    %%%%%%%%%%%%%%%%%按照VM进行AP与VM2Task的rei，reTransferdata的更新，CS的state的确认%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    temp_AP=AP;%原来状态是temp_AP，通过对temp_AP的判断改变AP
    for ap=1:size(AP_location,1)
        for vm=1:VMnum
            if temp_AP(ap).VM(vm).state==1&&temp_AP(ap).VM(vm).Nowin<=length(temp_AP(ap).VM(vm).task_list)%如果这个VM没有运行且，现在的指针小于任务列表任务数，则可执行。
                user_id=temp_AP(ap).VM(vm).user_id;
                Assignrank=sever{user_sever_choose{1,user_id},3};
                Map=sever{user_sever_choose{1,user_id},1};
                Nowin=temp_AP(ap).VM(vm).Nowin;%定义为一个指针
                Nowtask=temp_AP(ap).VM(vm).task_list(Nowin);%现在指向的任务号是Nowtask
                pretask=VM2Task(vm).Task(Nowtask).pre;
                pretaskrei=[];%现在所有前驱任务的剩余任务量
                for vm1=1:length(VM2Task)
                    if VM2Task(vm1).user_id==user_id;
                        user_vm2task=vm1;
                        break
                    end
                end
                for i=length(pretask)
                    pretaskrei(end+1)=VM2Task(user_vm2task).Task(pretask(i)).rei;
                end
                pretasktrans=[];%这个任务的前驱是否完成传输
                for i=1:length(pretask)
                    pretasktrans(end+1)=VM2Task(user_vm2task).reTransferdata(pretask(i),Nowtask);
                end
                if isempty(pretask)||(isempty(find(pretaskrei))==1&&isempty(find(pretasktrans))==1)%无前驱或者前驱任务量都剩零了并且已经传输完成
                    VM2Task(user_vm2task).Task(Nowtask).rei=VM2Task(user_vm2task).Task(Nowtask).rei-AP(ap).VM(vm).Pvm*clock_step;%更新VM2Task中的当先Task的rei
                    
                    AP(ap).VM(vm).cat=AP(ap).VM(vm).cat+clock_step;%刷新这个用户在这个AP上的一共的时间，最后会多加一个clock_step,因为最后一个任务，也有个时刻是前驱都完成的，也加入了一个clock_step
                    %                   AP(ap).VM(vm).Sumofcat=AP(ap).VM(1vm).Sumofcat+clock_step;
                    if VM2Task(user_vm2task).Task(Nowtask).rei<=0 %判断是否为最后一个时间点，让Task结束了，结束了之后，看后驱任务
                        VM2Task(user_vm2task).Task(Nowtask).rei=0;
                        
                        %                       Table(AP(ap).VM(vm).user_id).time(2,Nowtask)=clock;
                        suctask=VM2Task(user_vm2task).Task(Nowtask).suc;
                        if suctask==length(rank)%判断是否后驱就是exit任务了
                            exitpre=VM2Task(user_vm2task).Task(suctask).pre;
                            exitprerei=[];
                            for i=1:length(exitpre)
                                exitprerei(end+1)=VM2Task(user_vm2task).Task(exitpre(i)).rei;
                            end
                            if isempty(find(exitprerei))==1%exit任务的前驱都已经完成
                                %后驱为空，工作流结束
                                % AP(ap).VM(vm).cat=AP(ap).VM(vm).cat;%把前边的多加的clock_step去掉
                                user_id=AP(ap).VM(vm).user_id;%已经完成的user的ID记录下来，作为user_state的列变量
                                user_state(2,user_id)=clock;%完成时刻，这是一个clock的时间轴上的点，指的是这个时刻的结束，进行存储
                                user_state(3:5,user_id)=0;
                                AP_array=user_sever_choose{2,user_id}(1,:);
                                VM_array=user_sever_choose{2,user_id}(2,:);
                                for ap1=1:length(AP_array)
                                    user_state(3,user_id)=user_state(3,user_id)+AP(AP_array(ap1)).VM(VM_array(ap1)).cat;
                                    AP(AP_array(ap1)).VM(VM_array(ap1)).state=0;
                                    AP(AP_array(ap1)).VM(VM_array(ap1)).user_id=0;
                                    AP(AP_array(ap1)).VM(VM_array(ap1)).Nowin=0;
                                    AP(AP_array(ap1)).VM(VM_array(ap1)).cat=0;
                                    AP(AP_array(ap1)).VM(VM_array(ap1)).task_list=[];
                                    AP_used_vm(AP_array(ap1))=AP_used_vm(AP_array(ap1))-1;
                                    for cs=1:length(AP(AP_array(ap1)).CS)
                                        if isempty(find(AP(AP_array(ap1)).CS(cs).to==AP_array))~=1
                                            queue=AP(AP_array(ap1)).CS(cs).queue(VM_array(ap1));
                                            max_tqt=0;
                                            %                                             for fr=1:(AP(ap1).CS(cs).queue(VM_array(ap1)).front-1)
                                            %                                                 user_state(4,user_id)=user_state(4,user_id)+AP(ap1).CS(cs).queue(VM_array(ap1)).data(fr).tat;%在通信的过程中索要花费的一共的时间
                                            %                                                 user_state(5,user_id)=user_state(5,user_id)+(AP(ap1).CS(cs).queue(VM_array(ap1)).data(fr).tft-AP(AP_array(ap1)).CS(cs).queue(VM_array(ap1)).data(fr).gt)/(AP(AP_array(ap1)).CS(cs).queue(VM_array(ap1)).front-1);
                                            %                                             end
                                            queue.state=0;
                                            queue.from_vm=VM_array(ap1);
                                            queue.front=1;
                                            queue.rear=1;
                                            queue.data=struct('amount',0,'from_task',0,'to_task',0,'from_vm_id',0,'gt',0,'tft',0,'tat',0,'last_trans_clock',0);
                                            %                                     AP(ap1).CS(cs).queue(vm).data.from_task=0;
                                            %                                     AP(ap1).CS(cs).queue(vm).data.to_task=0;
                                            %                                     AP(ap1).CS(cs).queue(vm).data.amount=0;
                                            %                                     AP(ap1).CS(cs).queue(vm).data.from_vm_id=0;
                                            %                                     AP(ap1).CS(cs).queue(vm).data.gt=0;
                                            %                                     AP(ap1).CS(cs).queue(vm).data.tft=0;
                                            %                                     AP(ap1).CS(cs).queue(vm).data.tat=0;
                                            %                                     AP(ap1).CS(cs).queue(vm).data.last_trans_clock=0;%这种赋值方法根本没法在data有两个或者两个以上的struct的情况赋值，用struct语句
                                            AP(AP_array(ap1)).CS(cs).queue(VM_array(ap1))=queue;
                                        end
                                    end
                                end
                                for i=1:length(rank)
                                    VM2Task(user_vm2task).Task(i).rei=Iq(i); %任务剩余量的声明并初始化
                                    VM2Task(user_vm2task).reTransferdata=Transferdataq;
                                end
                                VM2Task(user_vm2task).user_id=0;
                            end
                            save([data_name]);
                            % % % % % % % % % % % % % % % % % % % % % %                          save
                        else %承接上一部分Task结束之后，后驱不是exit任务
                            for vm2=1:length(VM2Task)
                                if VM2Task(vm2).user_id==user_id;
                                    user_vm2task=vm2;
                                    break;
                                end
                            end
                            for i=1:length(suctask)
                                suc_id=suctask(i);%后驱任务的id
                                receiver=VM2Task(user_vm2task).Task(suc_id).Map_AP;%后驱任务所在的AP,VM2Task(1)中就可以找到
                                if ap==receiver%在这个ap执行,无需CS
                                    VM2Task(user_vm2task).reTransferdata(Nowtask,suc_id)=0;
                                    VM2Task(user_vm2task).Task(Nowtask).rei=0;
                                else %不在这个ap执行，则通过CS发送到其他的AP
                                    for j=1:length(AP(ap).CS)
                                        if AP(ap).CS(j).to==receiver
                                            choice=j;
                                            break;
                                        end
                                    end
                                    
                                    if AP(ap).CS(choice).queue(vm).state==0
                                        AP(ap).CS(choice).queue(vm).state=2;%预备状态，程序执行的这个clock当中，并不执行,当这一时刻传输处理完成之后，变为1。此时rear==front==1，加入数据后，rear依然指向队尾，front依然指向队头
                                    else
                                        AP(ap).CS(choice).queue(vm).rear=AP(ap).CS(choice).queue(vm).rear+1;%当还有其他的data到达的时候，rear指向最后一个data
                                    end
                                    rear=AP(ap).CS(choice).queue(vm).rear;
                                    AP(ap).CS(choice).queue(vm).data(rear).from_task=Nowtask;
                                    AP(ap).CS(choice).queue(vm).data(rear).to_task=suc_id;
                                    AP(ap).CS(choice).queue(vm).data(rear).amount=Transferdataq(Nowtask,suc_id);
                                    AP(ap).CS(choice).queue(vm).data(rear).from_vm_id=vm;
                                    AP(ap).CS(choice).queue(vm).data(rear).gt=clock;
                                    AP(ap).CS(choice).queue(vm).data(rear).tft=0;
                                    AP(ap).CS(choice).queue(vm).data(rear).tat=0;
                                    AP(ap).CS(choice).queue(vm).data(rear).last_trans_clock=0;%
                                end
                            end
                        end
                        AP(ap).VM(vm).Nowin=Nowin+1;
                        
                    end
                end
            end%对应temp_AP(ap).VM(vm).state==1&&(temp_AP(ap).VM(vm).Nowin<=length(temp_AP(ap).task_id_list))
            if AP(ap).VM(vm).state==2
                AP(ap).VM(vm).state=1;
            end
        end
    end
    %%%%%%%%%%%%%%%%%按照给定的CS的状态进行传输%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    for ap=1:size(AP_location)
        for cs=1:length(temp_AP(ap).CS)
            channel_num=length(temp_AP(ap).CS(cs).channel_num);
            pointer=temp_AP(ap).CS(cs).pointer;%pointer指向队列
            i=1;
            empty_queue=0;
            while i<=channel_num&&empty_queue<VMnum% pointer从1到10搜索，当搜到十个空的时候，说明没有传输了
                pointer=mod(pointer,VMnum);
                if pointer==0
                    pointer=VMnum;
                end
                if AP(ap).CS(cs).queue(pointer).state==1%queue内有数据，clock0到clock1这段时间中，没有数据进入
                    front=AP(ap).CS(cs).queue(pointer).front;%队头
                    AP(ap).CS(cs).queue(pointer).data(front).amount=AP(ap).CS(cs).queue(pointer).data(front).amount-B*clock_step;
                    if  AP(ap).CS(cs).queue(pointer).data(front).last_trans_clock~=clock%当queue数小于Channel数的时候，这一个clock中，有可能同一个queue被几个Channel共同传输
                        AP(ap).CS(cs).queue(pointer).data(front).last_trans_clock=clock;%当两者相等的时候，说明此时还是在搜索queue的过程当中，这时信道还没完全的分配满，在同一个clock之内，不用更新
                        AP(ap).CS(cs).queue(pointer).data(front).tat= AP(ap).CS(cs).queue(pointer).data(front).tat+clock_step;%可以刷新的时候，data的通信时间加上
                    end
                    if  AP(ap).CS(cs).queue(pointer).data(front).amount<=0%这个data的数据传输完成
                        AP(ap).CS(cs).queue(pointer).data(front).amount=0;
                        from_task=AP(ap).CS(cs).queue(pointer).data(front).from_task;
                        to_task=AP(ap).CS(cs).queue(pointer).data(front).to_task;
                        user_id=AP(ap).VM(pointer).user_id;
                        for vm2=1:length(VM2Task)
                            if VM2Task(vm2).user_id==user_id;
                                user_vm2task=vm2;
                                break;
                            end
                        end
                        VM2Task(user_vm2task).reTransferdata(from_task,to_task)=0;
                        
                        
                        
                        AP(ap).CS(cs).queue(pointer).data(front).tft=clock;%这个data的完成时间
                        
                        %一个数据块传完了，两件事情：1 更改子任务的pre的状态； 2 队头front后移
                        %                             AP(r).CS(receiver).QUEUE(pointer).data(front)  % 打印
                        %                          from_vm= AP(ap).CS(cs).queue(pointer).from_vm;
                        %                          VM2Task(from_vm).Task(Nowtask).rei=0;
                        %2 队头front后移，并判断队列中还有没有数据，没有则队列状态转0
                        AP(ap).CS(cs).queue(pointer).front=front+1;
                        if AP(ap).CS(cs).queue(pointer).front>AP(ap).CS(cs).queue(pointer).rear%队头比队尾大
                            AP(ap).CS(cs).queue(pointer).state=0;
                            AP(ap).CS(cs).queue(pointer).rear=AP(ap).CS(cs).queue(pointer).rear+1;%队列指针都指向队尾的空位置
                        end
                    end
                    empty_queue=0;
                else%队列为空
                    i=i-1;
                    empty_queue=empty_queue+1;
                end
                i=i+1;
                pointer=pointer+1;
            end
            AP(ap).CS(cs).pointer=pointer;
        end %AP(r)的CS遍历结束
    end
    for ap=1:size(AP_location)
        for cs=1:length(temp_AP(ap).CS)
            for vm=1:VMnum
                if AP(ap).CS(cs).queue(vm).state==2
                    AP(ap).CS(cs).queue(vm).state=1;
                end
            end
        end
    end
    %%%%%%%%%% 所有新接纳的用户的计算均从下一个clock_step开始；%%%%%%%%%%%%
    
    
    %         for i=2:length(rank)-1
    %             if VM2Task(1).Task(i).rei~=I(i-1)&&sign(i)==1
    %                 Table(1,i)=clock;
    %                 sign(i)=0;
    %             end
    %         end
    
    clock=clock+clock_step;
    %     end_time=datestr(now);
    clock
end
